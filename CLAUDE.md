# CLAUDE.md — Правила разработки

Это корпоративное приложение геймификации на Next.js. Файл содержит обязательные правила для Claude Code при работе с проектом.

## Стек технологий

- **Next.js 15** (App Router, SSR/SSG)
- **React 19** с функциональными компонентами и хуками
- **TypeScript 5** — строгая типизация везде
- **Tailwind CSS 4** — utility-first стили, никакого inline-CSS
- **Framer Motion** — анимации
- **Lucide React** — иконки
- **Recharts** — графики и диаграммы
- **Zod** — валидация данных на сервере и типизация форм

## Принципы разработки

### DRY (Don't Repeat Yourself)
Любая логика, которая встречается более одного раза, выносится в переиспользуемую функцию, хук или компонент.
Дублирование кода — это ошибка, а не вариант.

### KISS (Keep It Simple, Stupid)
Простое решение всегда лучше сложного. Не усложнять архитектуру "на будущее" — проектировать под текущую задачу.

### YAGNI (You Aren't Gonna Need It)
Не писать код, который "может понадобиться". Реализовывать только то, что требуется прямо сейчас.

### SOLID
- **S** — каждый компонент/функция делает одно дело
- **O** — расширять через props/composition, не через модификацию существующего кода
- **L** — дочерние компоненты не ломают контракт родительских
- **I** — интерфейсы узкие и специфичные, не монолитные
- **D** — зависеть от абстракций (интерфейсов), не от конкретных реализаций

### Composition over Inheritance
Предпочитать композицию компонентов наследованию. React-компоненты строятся через `children`, render props и HOC только при явной необходимости.

## Правила кода

### Общие
- Весь код — **TypeScript**, `any` запрещён
- Экспортировать типы явно, не полагаться на инференс там, где тип неочевиден
- Никаких `console.log` в коде, только для временной отладки с последующим удалением
- Переменные и функции называть по смыслу, не по типу (`userList`, не `array`)
- Комментарии — только там, где логика неочевидна. Не дублировать код словами

### Пути и алиасы
- Всегда использовать алиас `@/` вместо относительных путей (`../../`)
- `@/` указывает на `src/`. Пример: `@/components/Button`, `@/modules/users`
- Относительные пути (`./`, `../`) допустимы только внутри одного модуля

### Порядок импортов
```ts
// 1. React / Next.js
// 2. Сторонние библиотеки (framer-motion, lucide-react, recharts)
// 3. Внутренние модули и компоненты через @/
// 4. Локальные файлы того же модуля (./utils, ./types)
// 5. Типы — последними (import type ...)
```

### Типы
- Типы конкретного модуля — в `src/modules/<name>/types.ts`
- Типы, нужные нескольким модулям — в `src/lib/types.ts`
- Не дублировать типы между модулями — выносить в `src/lib/types.ts` при первом повторении
- Предпочитать Zod-схемы обычным интерфейсам для данных, которые приходят извне (API, формы, URL-параметры)

### Компоненты React
- Только функциональные компоненты, никаких классовых
- Props описывать через `interface`, не `type` (если нет union)
- Дефолтные значения через деструктуризацию, не через `defaultProps`
- Один компонент = один файл. Файл называется так же, как компонент (`PascalCase`)
- Не делать компонент умнее, чем нужно: если компонент принимает данные — он их только отображает

```tsx
// Правильно
interface UserCardProps {
  name: string;
  points: number;
  rank?: number;
}

export function UserCard({ name, points, rank = 1 }: UserCardProps) {
  return (...)
}
```

### Файловая структура
```
src/
  app/           # Next.js App Router — страницы и layouts
  components/    # Переиспользуемые UI-компоненты (design system)
  modules/       # Бизнес-модули (см. раздел "Система модулей")
  lib/           # Утилиты, хелперы, типы, константы
  hooks/         # Кастомные React-хуки
  config/        # Настройки проекта (подключения, публичные ключи, константы приложения)
  docs/          # Документация по модулям для AI
```

- Общие UI-компоненты — `src/components/`
- Бизнес-логика — `src/modules/<module-name>/`
- Утилиты, константы, типы — `src/lib/`
- Подключения к сервисам и настройки — `src/config/`

### Стили и дизайн-система
- Только Tailwind CSS классы
- Сложные повторяющиеся наборы классов выносить в переменные или `cn()` утилиту
- Не смешивать Tailwind с inline-стилями (`style={{}}`)
- Адаптивность — mobile-first: `sm:`, `md:`, `lg:`

**Цвета — никакого хардкода:**
- Запрещено использовать произвольные HEX, RGB, HSL значения напрямую (`text-[#ff0000]`, `bg-[#1a2b3c]`)
- Все цвета — только через CSS-переменные или токены из дизайн-системы: `text-primary`, `bg-surface`, `border-muted` и т.д.
- Новые цвета добавляются в `globals.css` через CSS-переменные и затем используются через Tailwind

**Переиспользование компонентов:**
- Перед созданием нового компонента — проверить `src/components/` на наличие подходящего
- Кнопки, карточки, бейджи, инпуты, иконки — всегда из дизайн-системы проекта, не создавать дубли
- Если существующий компонент почти подходит — расширить его через props, не создавать копию

### Именование
| Сущность | Стиль | Пример |
|---|---|---|
| Компонент | PascalCase | `UserCard.tsx` |
| Хук | camelCase с `use` | `useUserData.ts` |
| Утилита/хелпер | camelCase | `formatPoints.ts` |
| Константа | UPPER_SNAKE_CASE | `MAX_POINTS` |
| Тип/Интерфейс | PascalCase | `UserProfile` |
| CSS-класс | kebab-case (Tailwind) | `text-primary-500` |

## Конфигурация проекта (`src/config/`)

Папка `src/config/` — единственное место для подключений к внешним сервисам и глобальных настроек приложения.

### Что хранится
- **Клиент Supabase** — инициализация с публичными ключами (`supabase.ts`)
- **Константы приложения** — название сайта, URL, ссылки на соцсети, публичные идентификаторы (`app.ts`)
- **Настройки окружения** — типизированный доступ к переменным из `process.env` (`env.ts`)

### Правила
- Секретные ключи (`SERVICE_ROLE`, приватные токены) — только в `.env.local`, в код не попадают
- Публичные ключи (`NEXT_PUBLIC_*`) — попадают в браузер, хранятся в `src/config/`, не разбрасываются по компонентам
- Импортировать конфиг через `@/config/<file>`, не читать `process.env` напрямую внутри компонентов или модулей
- Один файл конфига — одна зона ответственности (не смешивать Supabase и настройки приложения в одном файле)

## Server vs Client компоненты

Все компоненты в App Router — **Server Components по умолчанию**. Они рендерятся на сервере, могут читать данные напрямую, не попадают в JS-бандл.

### Когда добавлять `'use client'`
Только при необходимости:
- Используются хуки (`useState`, `useEffect`, `useRef`, `useTransition`)
- Используются браузерные API (`window`, `document`, `localStorage`)
- Нужны обработчики событий (`onClick`, `onChange`, `onSubmit`)
- Используются `useRouter`, `useSearchParams`, `usePathname`

### Правила границы
- `'use client'` ставить как можно **глубже** в дереве — на минимальном компоненте, которому это нужно
- Не делать клиентской целую страницу или layout ради одной кнопки
- Server Component может **импортировать** Client Component, но не наоборот (нельзя импортировать Server Component внутрь Client)
- Данные передаются из Server в Client через props — только сериализуемые значения (не функции, не классы)

```
page.tsx (Server) → передаёт данные через props
  └── UserList.tsx (Server) → рендерит список
        └── LikeButton.tsx (Client, 'use client') → кнопка с состоянием
```

## Loading и Error состояния

Next.js читает специальные файлы рядом с `page.tsx` автоматически:

- `loading.tsx` — показывается пока страница загружается (Suspense-обёртка)
- `error.tsx` — показывается при необработанном исключении в роуте

### Правила
- Каждая страница с асинхронными данными должна иметь `loading.tsx` рядом
- `error.tsx` должен быть клиентским компонентом (`'use client'`) — это требование Next.js
- Не писать spinner и try/catch в `page.tsx` вручную — использовать эти конвенции
- Suspense-границы внутри страницы — через `<Suspense fallback={...}>` вокруг нужного блока

## Server Actions, кэш и мутации

Вся работа с данными — через **Next.js Server Actions**. Клиентские fetch-запросы к API не используются без явной причины.

### Server Actions
- Хранятся в файлах с директивой `'use server'` внутри модуля: `modules/<name>/actions.ts`
- Называются глаголом действия: `createAchievement`, `updateUserPoints`, `deleteTransaction`
- Всегда возвращают типизированный результат: `{ success: true, data: T } | { success: false, error: string }`
- Валидация входных данных — на стороне сервера, не доверять клиенту

```ts
// modules/achievements/actions.ts
'use server'

export async function createAchievement(data: CreateAchievementInput) {
  // validate → mutate → revalidate
}
```

### Валидация данных
- Все входные данные в Server Actions **обязательно** валидируются через **Zod**
- Схемы валидации определяются в `src/modules/<name>/types.ts` и экспортируются
- Использовать `safeParse()` для обработки ошибок без исключений (без try/catch)
- Типы TypeScript для данных форм извлекать через `z.infer<typeof Schema>`

### Кэш и ревалидация
- Данные получать через `fetch` с явным указанием кэширования или через `cache()` из React
- После мутации всегда вызывать `revalidatePath()` или `revalidateTag()` — не оставлять стale-данные
- Теги кэша именовать константами: `'achievements'`, `'leaderboard'`, `'transactions'`
- Не использовать `{ cache: 'no-store' }` без причины — думать о производительности

### Мутации на клиенте
- Для вызова Server Actions на клиенте использовать `useActionState` или `useTransition`
- Показывать состояние загрузки через `isPending` из `useTransition`
- Ошибки сервера отображать пользователю, не глотать молча

```tsx
// Правильный паттерн мутации
const [isPending, startTransition] = useTransition()

function handleSubmit() {
  startTransition(async () => {
    const result = await createAchievement(data)
    if (!result.success) showError(result.error)
  })
}
```

### Формы
Два паттерна — выбирать по задаче:

**Вариант 1 — нативный** (предпочтительный для простых форм):
```tsx
<form action={createAchievement}>
  <input name="title" required />
  <button type="submit">Создать</button>
</form>
```

**Вариант 2 — `useTransition`** (когда нужен контроль):
- Кастомное поведение после успеха (редирект, уведомление, сброс формы)
- Сложная клиентская валидация перед отправкой
- Оптимистичные обновления UI

Правило: начинать с варианта 1, переходить к варианту 2 только при конкретной необходимости.

## Управление состоянием

| Тип состояния | Инструмент | Когда |
|---|---|---|
| UI-состояние | `useState` | Открыт/закрыт модал, текущий таб, локальная форма |
| Фильтры / поиск / пагинация | URL (`useSearchParams`) | Должно работать с кнопкой "назад" и копированием ссылки |
| Серверные данные | Server Component + queries | Данные из БД, не дублировать в клиентский стейт |

**Запрещено:**
- Хранить серверные данные в `useState` — они устаревают и вызывают рассинхронизацию
- Использовать URL для временного UI-состояния (hover, анимации)
- Создавать глобальный стейт-менеджер (Zustand, Redux) без явного согласования — серверного состояния достаточно

## Система модулей

Бизнес-логика организована по модулям в `src/modules/`. Каждый модуль — самодостаточная единица.

### Структура модуля
```
src/modules/<module-name>/
  actions.ts      # Server Actions (мутации)
  queries.ts      # Функции чтения данных (server-side)
  types.ts        # TypeScript типы модуля
  components/     # UI-компоненты, специфичные для модуля
  hooks/          # Клиентские хуки модуля (если нужны)
  index.ts        # Публичный API модуля (реэкспорты)
```

### Правила модулей
- Модули **не импортируют друг друга напрямую** — взаимодействие через `src/lib/` или props
- Публичный API модуля — только через `index.ts`, не импортировать внутренние файлы снаружи
- Каждый модуль имеет документацию в `src/docs/<module-name>.md`
- Название модуля — существительное во множественном числе: `achievements`, `users`, `transactions`

### Текущие модули
_(обновлять по мере создания)_
- Пусто — модули ещё не созданы

## Документация для AI (`src/docs/`)

Каждый модуль обязан иметь файл `src/docs/<module-name>.md`.

### Правила ведения документации
- **Стиль**: сухо, без воды. Только факты, необходимые для понимания логики и зависимостей
- **Запрещено**: примеры кода, очевидные описания, пересказ типов
- **Обязательно обновлять** после каждого изменения кода модуля — документация всегда актуальна

### Структура файла (`src/docs/<module>.md`)
```
# <module-name>

Одна фраза: что делает модуль.

## Логика работы
Как модуль функционирует: последовательность операций, ключевые алгоритмы,
потоки данных. Без примеров кода — только описание поведения.

## Зависимости
- Внешние сервисы, таблицы БД, другие модули через lib/

## Типы
Только нетривиальные типы с неочевидной структурой.

## Actions
- `actionName(params)` — что делает, какие side effects (revalidate)

## Queries
- `queryName(params)` — что возвращает, кэш-тег

## Ограничения
Бизнес-правила и инварианты, которые нельзя нарушать.
```

Перед работой с модулем — **прочитать `src/docs/<module>.md`**.

## Правила работы с AI (Claude Code)

### Обязательные шаги перед написанием кода
1. **Step-by-Step Thinking:** Перед тем как выдать код, кратко (одним абзацем) опиши план своих действий: какие файлы создашь, что изменишь, как это решит задачу.
2. **Verification Step:** После написания кода проведи внутреннюю проверку: соответствует ли он типам TypeScript, нет ли лишних импортов и соблюдены ли правила из этого файла.

### Перед написанием кода
1. **Читай существующий код и документацию** перед тем, как предложить изменения — не предполагай структуру
2. **Читай `src/docs/<module>.md`** если задача касается конкретного модуля
3. **Одна задача за раз** — не рефакторить попутно то, о чём не просили
4. **Не трогай то, что не сломано** — если задача касается одного компонента, не изменяй соседние

### При неопределённости — останавливаться и уточнять
Если задача допускает несколько архитектурных решений или требования неясны — **задать вопрос до начала работы**, не домысливать.

Остановиться и уточнить нужно если:
- Непонятно, в каком модуле должна быть логика
- Есть несколько равноценных подходов
- Задача затрагивает несколько модулей и неясен приоритет
- Требования к поведению (edge cases) не описаны

Не гадать, не "делать как кажется правильным" — задать конкретный вопрос с вариантами.

### Запрещено без явного запроса
- Добавлять новые зависимости в `package.json`
- Менять структуру роутинга (`app/` директория)
- Рефакторить рабочий код под предлогом "улучшения"
- Добавлять комментарии к коду, который не изменялся
- Писать `TODO`, `FIXME`, `HACK` без обсуждения
- Создавать новые файлы, если задача решается правкой существующих

### Масштаб изменений
- Минимальный diff = лучший diff
- Изменение должно быть ровно настолько большим, насколько нужно для задачи
- Если задача большая — разбить на шаги и согласовать подход

### Безопасность
- Никогда не хранить секреты, токены, ключи в коде или git
- Использовать переменные окружения (`.env.local`), которые в `.gitignore`
- Не доверять пользовательскому вводу — валидировать на границе системы

## Команды проекта

```bash
npm run dev      # Запуск dev-сервера
npm run build    # Production сборка
npm run lint     # Проверка ESLint
```

## Язык проекта

- UI и тексты — **русский язык**
- Код (переменные, функции, типы) — **английский язык**
- Комментарии в коде — **русский язык**
